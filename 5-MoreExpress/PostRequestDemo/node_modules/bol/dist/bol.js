// Does not really guarentee consistency but better than worst :(

// Bol Voices
 const bolVoices = {
  "UK English Female": [0, 1, 2, 3, 4, 5, 6],
  "UK English Male": [7, 8, 9, 10, 11, 12, 13],
  "US English Female": [14, 15, 16, 17, 18, 19, 20],
  "US English Male": [7, 8, 9, 10, 11, 12, 13]
}

// System Equivalent Fallbacks
 const fallbacks = [
  // UK English Female
  {
    "name": "Google UK English Female"
  },
  {
    "name": "en-AU",
    "rate": 0.25,
    "pitch": 1
  },
  {
    "name": "Agnes"
  },
  {
    "name": "inglés Reino Unido"
  },
  {
    "name": "English United Kingdom"
  },
  {
    "name": "English United Kingdom",
    "lang": "en_GB"
  },
  {
    "name": "Fallback en-GB Female",
    "lang": "en-GB",
    "fallbackvoice": true
  },


  // UK English Male & US English Male
  {
    "name": "Google UK English Male"
  },
  {
    "name": "en-GB",
    "rate": 0.25,
    "pitch": 1
  },
  {
    "name": "Daniel Compact"
  },
  {
    "name": "inglés Reino Unido"
  },
  {
    "name": "English United Kingdom"
  },
  {
    "name": "Daniel"
  },
  {
    "name": "Fallback UK English Male",
    "lang": "en-GB",
    "fallbackvoice": true,
    "service": "g1",
    "voicename": "rjs"
  },


  // US English Female
  {
    "name": "Google US English",
    "timerSpeed": 1
  },
  {
    "name": "English United States"
  },
  {
    "name": "inglés Estados Unidos"
  },
  {
    "name": "Vicki"
  },
  {
    "name": "en-US",
    "rate": 0.2,
    "pitch": 1,
    "timerSpeed": 1.3
  },
  {
    "name": "English United States",
    "lang": "en_US"
  },
  {
    "name": "Fallback English",
    "lang": "en-US",
    "fallbackvoice": true,
    "timerSpeed": 0
  }
]


// Helpers
function getFallbackVoices(voiceName) {
  // return first voice (Google UK English Female) if the voice does not exist in list
  if(!bolVoices[voiceName]) return [fallbacks[0]];

  return bolVoices[voiceName].map(id => fallbacks[id]);
}

function getCommonVoice(fallbackVoices, systemVoices) {
  for(let item of fallbackVoices) {
    let commonVoice = systemVoices.find(val => val.name === item.name);
    if(commonVoice) return commonVoice;
  }
}

async function wait(time) {
  return new Promise(resolve => {
    setTimeout(() => resolve(), time);
  })
}


function getSupportedVoice(bolVoice, systemVoices) {
  const fallbackVoices = getFallbackVoices(bolVoice);
  // getCommonValue returns common value between two arrays
  const supportedVoice = getCommonVoice(fallbackVoices, systemVoices)
  return supportedVoice;
}

// Helpers end

let retriesToSpeak = 0;
class Bol {
  constructor(defaultVoice = 'UK English Female', { rate, pitch, volume } = {rate: 1, pitch: 1, volume: 1}) {
    this.systemVoices = [];
    this.rate = rate;
    this.pitch = pitch;
    this.volume = volume;

    if(Object.keys(bolVoices).includes(defaultVoice)) {
      this.defaultVoice = defaultVoice;
    }else {
      this.defaultVoice = 'UK English Female';
    }
    
    this.init();
    this.speak = this.speak.bind(this);
    this.init = this.init.bind(this);
    speechSynthesis.onvoiceschanged = this.init;
  }

  init() {
    if(typeof speechSynthesis === 'undefined') return;
    this.systemVoices = speechSynthesis.getVoices();
  }

  async speak(text, newVoice = null) {
    if(this.systemVoices.length === 0 && retriesToSpeak < 10) {
      await wait(600);
      retriesToSpeak++;
      return this.speak(text, newVoice);
    }
    
    const voice = getSupportedVoice((newVoice || this.defaultVoice), this.systemVoices);
    console.log(this.defaultVoice);
    const utterThis = new SpeechSynthesisUtterance(text);
    utterThis.voice = voice || '';
    utterThis.voiceURI = voice.voiceURI || '';
    utterThis.volume = (this.volume === undefined || this.volume === null) ? 1 : this.volume;
    utterThis.rate = (this.rate === undefined || this.rate === null) ? .8 : this.rate;
    utterThis.pitch = (this.pitch === undefined || this.pitch === null) ? 1 : this.pitch;
    utterThis.text = text;
    utterThis.lang = voice.lang || 'en-US';

    speechSynthesis.speak(utterThis);
    
    return new Promise(resolve => {
      utterThis.onend = e => {
        resolve(e.elapsedTime);
      }
    })
  }

}

